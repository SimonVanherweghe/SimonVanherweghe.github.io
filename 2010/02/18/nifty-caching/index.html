<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="canonical" href="https://donebysimon.be/2010/02/18/nifty-caching/"><title>Nifty caching</title><style>ul[data-astro-cid-dlmosuxq]{display:flex;flex-wrap:wrap;gap:var(--space-xs);font-size:var(--step--1);color:var(--color-grey);margin-bottom:var(--space-xs)}a[data-astro-cid-dlmosuxq]{text-decoration:none;padding:var(--space-3xs) var(--space-2xs);border-radius:.5em}a[data-astro-cid-dlmosuxq]:hover{background-color:var(--color-accent);color:var(--color-bg)}
</style>
<link rel="stylesheet" href="/_astro/index.674fa69b.css" />
<style>header[data-astro-cid-fzx4jmue]{max-width:var(--max-width-content);margin:0 auto}div[data-astro-cid-fzx4jmue].markdown{max-width:var(--max-width-content);margin:0 auto;padding-bottom:var(--space-xl);border-bottom:var(--border)}.title[data-astro-cid-fzx4jmue]{font-size:var(--step-4);font-weight:400;margin-bottom:var(--space-m)}.desc[data-astro-cid-fzx4jmue]{font-size:var(--step-1);margin-bottom:var(--space-s)}.details[data-astro-cid-fzx4jmue]{font-size:var(--step--1);color:var(--color-grey);margin-bottom:var(--space-s)}aside[data-astro-cid-fzx4jmue]{max-width:var(--max-width-content);margin:var(--space-xl) auto}.pagination[data-astro-cid-fzx4jmue]{display:flex;justify-content:space-between;align-items:end}.pagination[data-astro-cid-fzx4jmue]>[data-astro-cid-fzx4jmue]{flex:1}.pagination[data-astro-cid-fzx4jmue]>[data-astro-cid-fzx4jmue]:last-child{text-align:right}
img[data-astro-cid-nephlaow]{aspect-ratio:16/8;object-fit:cover;margin-bottom:var(--space-xs);grid-area:img}
</style></head><body><div class="layout-wrapper"><header data-astro-cid-3ef6ksr2><div data-astro-cid-3ef6ksr2><h1 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2> DONEBYSIMON</a></h1><nav data-astro-cid-3ef6ksr2><ul data-astro-cid-3ef6ksr2><li data-astro-cid-3ef6ksr2><a href="/blog" data-astro-cid-3ef6ksr2>Blog</a></li><li data-astro-cid-3ef6ksr2><a href="/about" data-astro-cid-3ef6ksr2>About</a></li></ul></nav></div></header><main class="main"><article class="post" data-astro-cid-fzx4jmue><header data-astro-cid-fzx4jmue><ul data-astro-cid-dlmosuxq></ul><h1 class="title" data-astro-cid-fzx4jmue>Nifty caching</h1><div class="details" data-astro-cid-fzx4jmue><time datetime="2010-02-18T22:27:31.000Z" data-astro-cid-fzx4jmue>2/18/2010</time></div></header><div class="markdown" data-astro-cid-fzx4jmue><p>De beginpagina bestaat uit content die van op verschillende plaatsten komt. Die telkens te gaan ophalen en verwerken zou te veel tijd in beslag nemen en de server onnodig bezig houden. Ik moest dus wel wat aandacht aan de performantie wijden, gewoon voor jullie, dat jullie niet telkens te lang moeten wachten. Ik heb dit op verschillende niveau‚Äôs aangepakt:</p>
<p><strong>Alles in √©√©n<br>
Er staat een script op de server dat alle content ophaalt en dit dan wegschrijft in een bestandje. Bij een bezoek is het gewoon een kwestie van die weggeschreven content uit te lezen. Die content moet natuurlijk zo nu en dan een update krijgen, maar straks meer daar over.</strong></p>
<p><strong>Minder http requests<br>
Een webpagina bestaat uit vele bestanden (javascripts, stylesheets‚Ä¶) Voor ieder bestand is er een http request nodig om dit te gaan ophalen. Dit brengt op zich al een vertraging met zich mee. Een oplossing kan zijn om alles in √©√©n groot bestand te stoppen, maar dat is verre van praktisch. Ik ben op <a href="http://rakaz.nl/2006/12/make-your-pages-load-faster-by-combining-and-compressing-javascript-and-css-files.html" title="http://rakaz.nl/2006/12/make-your-pages-load-faster-by-combining-and-compressing-javascript-and-css-files.html">een handig script</a> uitgekomen dat dit oplost. Alle losse bestanden worden onderschept en in √©√©n groot bestand gestopt √©n als surplus gecached.</strong></p>
<p><strong>Cachen<br>
De beginpagina is php, kortweg haalt die de inhoud uit het contentbestand, zet alles op de juiste plaats en maakt de WordPress blog aan. Alles gaat naar de gebruiker in de vorm van een html pagina, zoals alle php pagina‚Äôs. Met het cachen sla ik die gegenereerde pagina op. Bij een volgend bezoek geef ik gewoon die gecachte pagina weer. Als er niks veranderd is, dan moet er ook niks opnieuw gegenereerd worden. Ik heb <a href="http://www.developertutorials.com/tutorials/php/php-caching/page1.html" title="http://www.developertutorials.com/tutorials/php/php-caching/page1.html">die mosterd hier</a> gehaald.</strong></p>
<p>Nu moet je ooit wel eens opnieuw je pagina laten genereren. Je kan dat bijvoorbeeld na een bepaalde tijd doen of door eerst te kijken of er wel iets aangepast is. Ik heb voor dit laatste gekozen: als het contentbestand recenter is dan de gecachte pagina, dan moet de pagina opnieuw gegenereerd worden.</p>
<p><strong>Content updaten<br>
Het contentbestand moet zo nu en dan ge-update worden. Dit zou kunnen met een zogenaamde cronjob, waarbij de server een script om-de-zoveel-tijd gaat uitvoeren. Maar dit is niet ideaal: wacht ik te lang met updaten, dan is de content hier niet up-to-date. Laat ik het te vaak runnen, dan zorgt dit voor onnodige belasting van de server.<br>
Het interval van updaten zal bepaald worden door de content die het snelst aangepast is, dit is -hier zeker- Twitter.<br>
Bij het posten van een blog item kan je pingen, laten weten aan een of andere service dat er een nieuwe post is. Bij Twitter kan dit niet, (of toch niet dat ik weet) dus moet ik het anders doen.<br>
Eenmaal de pagina volledig is ingeladen stuur ik een <a href="http://nl.wikipedia.org/wiki/Asynchronous_JavaScript_and_XML" title="http://nl.wikipedia.org/wiki/Asynchronous_JavaScript_and_XML">Ajax</a> request naar de server met daarin de id van de laatste tweet die op die pagina staat. Hier heeft de gebruiker geen last van, de pagina is al compleet ingeladen. De server gaat kijken of er een tweets zijn met id‚Äôs die groter zijn dan deze die op de pagina staan. Als dit het geval is worden deze terug gezonden naar de gebruiker en in de lijst met tweets geplaatst. Op dit punt ziet de gebruiker een up-to-date lijst met tweets. Als er nieuwe tweets gevonden zijn (en alleen dan) vertrekt er opnieuw een Ajax request naar de server, maar dan om het content bestand opnieuw te genereren. Bij de volgende pagina weergave zal blijken dat het content bestand recenter is dan de cache, en krijgt men meteen de up-to-date lijst met tweets (√©n al de rest)</strong></p>
<p><strong>Resultaten<br>
<strong>Ophalen, verwerken en wegschrijven van content naar contenbestand: 4.28s<br>
Inladen beginpagina in Firefox, browsercache uitgeschakeld:</strong></strong></p>
<p>Firebug</p>
<p>Html</p>
<p>CSS</p>
<p>Javascript</p>
<p>Meerdere requests<br>
Geen caching</p>
<p>1.82 s</p>
<p>392 ms</p>
<p>859 ms</p>
<p>Gebundelde requests<br>
Geen caching</p>
<p>1.63 s</p>
<p>254 ms</p>
<p>571 ms</p>
<p>Gebundelde requests<br>
Caching</p>
<p>157 ms</p>
<p>170 ms</p>
<p>568 ms</p>
<p>Vooral bij het cachen is het resultaat erg zichtbaar. De rest valt nog mee.<br>
Zonder dit alles zou elke weergave van de beginpagina meer dan 5 seconden duren‚Ä¶</p>
<p><strong>Maar‚Ä¶<br>
Er zijn wel wat kanttekeningen bij: bij elke homepagina weergave vertrekt er achteraf nog een request naar de server. Deze moet dan telkens Twitter gaan aanspreken, dat is overkill. Qua bezoekers zal het hier wel nog meevallen, maar echt fijn is het niet. Er zou op z‚Äôn minst een soort tijdslimiet mogen inzitten, dat hij maar 1 keer per minuut gaat controleren of zo‚Ä¶<br>
Alles is wat experimenteel, 2-3 manieren samen gesmeten, hmm. Maar alles lijkt goed te werken, we zien wel.</strong></p>
<p><strong>Update</strong><br>
Met @ikbenmartijn wat over-en-weer zitten tweeten, en tot de volgende inzicht gekomen:</p>
<ul>
<li>Ik heb de datum nodig van de laatste zijn-er-nog tweets request</li>
<li>M‚Äôn eerste idee was om die datum ook bij te houden in het content bestand. Telkens als een request binnen komt voor nieuwe tweets, dan de datum daar gaan aanpassen.</li>
<li>Met het aanmaken van de index pagina, gewoon die datum in de javascript zetten, en die kan dan gaan kijken of er genoeg tijd tussen de requests zou zitten.</li>
<li>Enigste probleem hierbij: die index pagina is gecached natuurlijk, en dat wil zeggen dat die geen recente datum info kan hebben staan <span role="img" aria-label="slightly smiling face">üôÇ</span></li>
</ul></div><aside data-astro-cid-fzx4jmue><nav class="pagination" data-astro-cid-fzx4jmue><a href="/2010/08/04/iphone-internet-access-in-rwanda-and-congo/" data-astro-cid-fzx4jmue><span data-astro-cid-fzx4jmue>‚Üê</span><span data-astro-cid-fzx4jmue>iPhone internet access in Rwanda and Congo</span></a><a href="/2010/02/17/fijne-webwaren/" data-astro-cid-fzx4jmue><span data-astro-cid-fzx4jmue>Fijne webwaren!</span><span data-astro-cid-fzx4jmue>‚Üí</span></a></nav></aside></article></main><footer data-astro-cid-sz7xmlte><div data-astro-cid-sz7xmlte><p data-astro-cid-sz7xmlte>DoneBySimon &copy; 2024</p><ul class="footer__links" data-astro-cid-sz7xmlte><li data-astro-cid-sz7xmlte><a href="https://www.instagram.com/donebysimon/" target="_blank" rel="noopener noreferrer" data-astro-cid-sz7xmlte>Instagram</a></li><li data-astro-cid-sz7xmlte><a href="https://github.com/simonvanherweghe" target="_blank" rel="noopener noreferrer" data-astro-cid-sz7xmlte>GitHub</a></li><li data-astro-cid-sz7xmlte><a href="https://twitter.com/donebysimon" target="_blank" rel="noopener noreferrer" data-astro-cid-sz7xmlte>X</a></li><li data-astro-cid-sz7xmlte><a href="/feed.xml" data-astro-cid-sz7xmlte>RSS</a></li><li data-astro-cid-sz7xmlte><a href="/archive" data-astro-cid-sz7xmlte>The Archive</a></li></ul></div></footer></div></body></html>